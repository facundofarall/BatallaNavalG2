################################################################################
#                                                                              #
#    Micro Series 6801 Assembler V2.00/DOS              28/Nov/17  14:33:12    #
#                                                                              #
#       Source   =   main_bn.msa                                               #
#       List     =   main_bn.lst                                               #
#       Object   =   main_bn.r07                                               #
#       Options  =                                                             #
#                                                                              #
#                                               (c) Copyright IAR Systems 1990 #
################################################################################


    1  0000                           p68h11
    2                 
    3                 $macros.msa
    4                 **********************************
    5                 * definicion de macro utilizados *
    6                 **********************************
    8                 * limpia display bitmap
    9  0000                           MACRO   %CLS
   10                                 
   11                                 ldx             #display
   12                                 ldaa            #ARRAY_L
   13                                 ldab            #$03
   14                 cls\@           stab            0,X
   15                                 inx
   16                                 deca
   17                                 bne             cls\<
   18                 
   19  0000                           ENDMAC
   20                 
   21                 * espera
   22  0000                           MACRO   %EXPECT
   23                                 
   24                 expe\@          jsr             read_kb
   25                                 tsta
   26                                 bmi             expe\.
   27                                 cmpa            #\0
   28                                 bne             expe\<
   29                 
   30  0000                           ENDMAC
   31                 
   32                 * soltar
   33  0000                           MACRO   %KEEP
   34                                 
   35                 keep\@          jsr             read_kb
   36                                 cmpa            #\0
   37                                 beq             keep\<
   38                 
   39  0000                           ENDMAC
   40                 * filter array auxiliar
   41  0000                           MACRO   %FIX_ARRY
   42                 
   43                                 ldx             SA_MAT,Y
   44                                 ldaa            #ARRAY_L
   45                 loop\@          ldab            0,X
   46                                 andb            #11000000b
   47                                 orab            #00000011b
   48                                 stab            0,X
   49                                 inx
   50                                 deca
   51                                 bne             loop\<
   52                 
   53  0000                           ENDMAC
   54                 
   55                 * clear array auxiliar
   56  0000                           MACRO   %CLR_AUX
   57                                 
   58                                 ldx             #arry_aux
   59                                 ldaa            #N_AUX*SA_SIZE
   60                                 ldab            #0
   61                                 jsr             clrarray
   62                 
   63  0000                           ENDMAC
   64                 
   65                 * para ir actualizando el display
   66  0000                           MACRO   %REFRESH
   67                 
   68                                 pshy
   69                                 ldx             SA_MAT,Y
   70                                 pshx
   71                                 clra
   72                                 psha
   73                                 ldy             #display
   74                                 pshy
   75                                 ldaa            #ARRAY_L
   76                                 psha
   77                                 jsr             mirror
   78                                 pula
   79                                 puly
   80                                 pula
   81                                 pulx
   82                                 puly    
   83                 
   84  0000                           ENDMAC
   85                 
   86                 * saltos que pasan el limite
   87  0000                           MACRO   %GOTO
   88                 
   89                                 jmp     \0
   90                 
   91  0000                           ENDMAC
   92                 
   93                 * agrega posicion al arreglo de posiciones prohibidas
   94                 * toma en A la fila y en B la columna
   95  0000                           MACRO   %PROH_POS
   96                                 
   97                                 tsta
   98                                 bne             oka\@
   99                                 ldaa            #$FF
  100                 oka\<           tstb
  101                                 bne             okb\@
  102                                 ldab            #$FF
  103                 okb\<           psha
  104                                 pshb
  105                                 ldx             #arry_pr
  106                                 pshx
  107                                 clra
  108                                 psha
  109                                 jsr             play_wrt
  110                                 pula
  111                                 pulx
  112                                 pulb
  113                                 pula
  114                 
  115  0000                           ENDMAC
  116                 
  117                 * agrega las posiciones de la periferia de una posicion al arreglo
  118                 * de prohibidas, tomando en A la fila y en B la columna de dicha posicion
  119                 
  120  0000                           MACRO   %PROH_PER
  121                                         
  122                                 inca
  123                                 %PROH_POS
  124                         
  125                                 deca
  126                                 incb
  127                                 %PROH_POS
  128                 
  129                                 deca
  130                                 decb
  131                                 %PROH_POS
  132                 
  133                                 inca
  134                                 decb
  135                                 %PROH_POS
  136                 
  137  0000                           ENDMAC
  138                 
  139                 * escribe una posicion en la matriz del tablero y toma
  140                 * por A como fila y B como columna de dicha posicion
  141                 * el parametro \0 indica que tipo de barco es el grabado
  142                 
  143  0000                           MACRO   %SET_POS
  144                 
  145                                 ldaa            #\0
  146                                 psha
  147                                 ldaa            SA_FIL,Y
  148                                 psha
  149                                 ldab            SA_COL,Y
  150                                 pshb
  151                                 ldx             SA_MAT,Y
  152                                 pshx
  153                                 clra
  154                                 psha
  155                                 jsr             writepos
  156                                 pula
  157                                 pulx
  158                                 pulb
  159                                 pula
  160                                 pula
  161                 
  162  0000                           ENDMAC
  163                 
  164                 * me fijo que la posicion este o no este en el arreglo de posiciones
  165                 * prohibidas, la A se toma como la fila y la B como la columna
  166                 
  167  0000                           MACRO   %IS_PROH
  168                 
  169                                 psha
  170                                 pshb
  171                                 ldx             #arry_pr
  172                                 pshx
  173                                 clra
  174                                 psha
  175                                 jsr             play_src
  176                                 pula
  177                                 pulx
  178                                 pulb
  179                                 pula
  180                 
  181  0000                           ENDMAC
  182                 
  183                 * agrego una posicion al arreglo auxiliar para cargueros
  184                 * y se toma que en A esta la fila y en B la columna
  185                 
  186  0000                           MACRO   %AUX_POS
  187                 
  188                                 psha
  189                                 pshb
  190                                 ldx             #arry_aux
  191                                 pshx
  192                                 clra
  193                                 psha
  194                                 jsr             play_wrt
  195                                 pula
  196                                 pulx
  197                                 pulb
  198                                 pula
  199                 
  200  0000                           ENDMAC
  201                 
  202                 * establezco el arreglo auxiliar con las posiciones
  203                 * perifericas del carguero, toma en A fila y B columna
  204                 * de la parte uno del carguero
  205                 
  206  0000                           MACRO   %SET_AUX
  207                                 
  208                                 inca
  209                                 %AUX_POS
  210                                 
  211                                 deca
  212                                 incb
  213                                 %AUX_POS
  214                                 
  215                                 deca
  216                                 decb
  217                                 %AUX_POS
  218                 
  219                                 inca
  220                                 decb
  221                                 %AUX_POS                
  222                 
  223  0000                           ENDMAC
  224                 
  225                 * invocar a la subrutina writepos
  226  0000                   MACRO   %WRITEPOS
  227                                 ldab            \0
  228                                 pshb                            ;se envía el byte a escribir
  229                                 ldab            12,x
  230                                 pshb                            ;se envía letra (fila)
  231                                 ldab            11,x
  232                                 pshb                            ;se envía num (columna)
  233                                 ldy             9,x
  234                                 pshy                            ;se envía dirección de inicio de matriz
  235                                 ldab            8,x
  236                                 pshb                            ;se envía jugador atacado
  237                                 jsr             writepos
  238                                 %CLRST          6
  239  0000                   ENDMAC
  240                 
  241                 * invocar a la subrutina writepos
  242  0000                   MACRO   %PLAY_WRT
  243                                 ldab            12,x
  244                                 pshb                            ;se envía letra (fila)
  245                                 ldab            11,x
  246                                 pshb                            ;se envía num (columna)
  247                                 ldy             14,x
  248                                 pshy                            ;se envía inicio de array
  249                                 ldab            8,x
  250                                 pshb                            ;se envía jugador atacado
  251                                 jsr             play_wrt
  252                                 %CLRST          5
  253  0000                   ENDMAC
  254                 
  255                 * realizar back up de AccA, AccB, IX e IY
  256  0000                   MACRO   %BACKUP
  257                                 psha
  258                                 pshb
  259                                 pshx
  260                                 pshy
  261  0000                   ENDMAC
  262                 
  263                 * realizar restore de AccA, AccB, IX e IY
  264  0000                   MACRO   %RESTORE
  265                                 puly
  266                                 pulx
  267                                 pulb
  268                                 pula
  269  0000                   ENDMAC
  270                 
  271                 * limpiar el stack de datos enviados
  272  0000                   MACRO   %CLRST
  273                 CONT_M          SET     \0
  274                                 IF CONT_M > 0
  275                                 ins
  276                                 %CLRST  CONT_M-1
  277                                 ENDIF
  278  0000                   ENDMAC
  279                 * activar un led en funcion de una variable
  280  0000                   MACRO   %LED_INV
  281                                 ldaa            PORTA
  282                                 eora            #SHF_LED
  283                                 staa            PORTA
  284  0000                   ENDMAC
  285                 
  286                 * declarar o reservar variables locales en subrutinas
  287  0000                   MACRO   %MALLOC
  288                                 IF \0 > 0
  289                                 tsx
  290                                 xgdx
  291                                 subd    #\0
  292                                 xgdx
  293                                 txs
  294                                 ENDIF
  295  0000                   ENDMAC
  296                 
  297                 * liberar espacio de variables en subrutinas
  298  0000                   MACRO   %RELMEM
  299                                 IF \0 > 0
  300                                 tsx
  301                                 xgdx
  302                                 addd    #\0
  303                                 xgdx
  304                                 txs
  305                                 ENDIF           
  306  0000                   ENDMAC
  307                 
  308                 *************
  309                 * CONSTANTS *
  310                 *************
  311  0000           P1              EQU             0
  312  0001           P2              EQU             1
  313  0002           PN              EQU             2               ;cantidad de jugadores
  314                 
  315  0006           MAX_C           EQU             6
  316  0001           MIN_C           EQU             1
  317  000F           MAX_F           EQU             15
  318  000A           MIN_F           EQU             10              
  319                 
  320  0003           WAT_NP          EQU             00000011b
  321  0043           SUB_NP          EQU             01000011b
  322  0083           SHI_NP          EQU             10000011b
  323  0008           WATER           EQU             00001000b       ;verde
  324  0070           SUNK_SUB        EQU             01110000b       ;rojo para submarinos
  325  00B8           HIT             EQU             10111000b       ;amarillo
  326  00B0           SUNK_SHI        EQU             10110000b       ;rojo para cargueros
  327                 
  328  0006           FILA            EQU             6
  329  0006           COL             EQU             6
  330  0024           ARRAY_L         EQU             FILA*COL
  331  000A           NORM            EQU             10
  332                 
  333  000A           MIN_FIL         EQU             10
  334  000F           MAX_FIL         EQU             15
  335  0001           MIN_COL         EQU             1
  336  0006           MAX_COL         EQU             6       
  337                 
  338  0000           CONT            EQU             0
  339  0002           FILA_L          EQU             2
  340  0001           COL_L           EQU             1
  341                 
  342  0003           INPUTS          EQU             3
  343                 
  344  FFFF           NONE            EQU             -1
  345  0003           MASK_FIL        EQU             3
  346  0002           MASK_COL        EQU             2
  347  0001           COL_CONT        EQU             1
  348  0000           KB_PRESS        EQU             0
  349                 
  350                 ******* Ports ***************************
  351                 
  352  1007           DDRC            EQU             $1007           ;data direction register for C
  353  1002           PIOC            EQU             $1002           ;for strobe B assertion change
  354  1005           PORTCL          EQU             $1005           ;port C latched
  355  1004           PORTB           EQU             $1004           ;port B
  356  1003           PORTC           EQU             $1003           ;rows
  357  1000           PORTA           EQU             $1000
  358                 
  359  0040           SHF_LED         EQU             $40
  360                 
  361                 ******* Cols and Row Ports **************
  362                 
  363  1003           ROWS            EQU             PORTC           ;outputs
  364  1005           COLS            EQU             PORTCL          ;inputs
  365                 
  366                 ***** Col Mask **************************
  367  0010           COL0            EQU             00010000b
  368                          
  369                 ***** Row Masks *************************
  370                 
  371  000E           FIL0            EQU             00001110b       ;mascaras para manejo de filas
  372  000D           FIL1            EQU             00001101b
  373  000B           FIL2            EQU             00001011b
  374  0007           FIL3            EQU             00000111b
  375                 
  376  0004           LENGTH          EQU             4               ; largo del display
  377                 
  378                 ****** Keyboard Mask ********************
  379  0008           Button_1        EQU             8
  380  0009           Button_2        EQU             9
  381  000A           Button_3        EQU             10
  382  000C           Button_4        EQU             12
  383  000D           Button_5        EQU             13
  384  000E           Button_6        EQU             14              
  385  0000           Button_A        EQU             0       
  386  0001           Button_B        EQU             1
  387  0002           Button_C        EQU             2
  388  0004           Button_D        EQU             4
  389  0005           Button_E        EQU             5
  390  0006           Button_F        EQU             6
  391  000B           B_fire          EQU             11
  392  0003           B_P1            EQU             3
  393  0007           B_P2            EQU             7
  394  000F           B_reset         EQU             15
  395                 
  396  0000           EOT             EQU             0
  397  0020           ESP             EQU             $20     
  398                 
  399                 *========================================================
  400                 * El siguiente es un programa de un juego de batalla
  401                 * naval para dos jugadores en el emulador Wookie FX.
  402                 *========================================================
  403                 
  404                 ****************
  405                 * MAIN PROGRAM *
  406                 ****************
  407                 
  408  2000                           ORG             $2000
  409  2000           init            EQU             *
  410  2000 8E4257                    lds             #STACKP
  411                 
  412                 * INICIALIZAR DISPLAY Y TECLADO
  413  2003 BD29B1                    jsr             initdis         ;inicialización de display 7 seg
  414  2006 BD29A9                    jsr             init_kb         ;inicialización de teclado
  415                 
  416                 * LIMPIAR ARREGLO DE BARCOS ATACADOS
  417  2009 CE4284                    ldx             #hitlist
  418  200C 3C                        pshx                            ;se envía inicio de arreglo de barcos a poner en 0
  419  200D 8636                      ldaa            #(HITSIZE*2)
  420  200F 36                        psha                            ;se envía el tamaño del arreglo a limpiar
  421  2010 BD2847                    jsr             clrzone
  422  2013                           %CLRST          3
  423                 
  424                 * DEFINIR CANTIDAD DE BARCOS A UTILIZAR
  425  2016 BD26E4                    jsr             def_ships
  426  2019 B6425B                    ldaa            cant_sub        ;se carga cantidad de submarinos
  427  201C F6425C                    ldab            cant_shi        ;se carga cantidad de cargueros
  428  201F 58                        lslb                            ;se multiplica a la cantidad de cargueros por dos, así se obtiene las posiciones atacables
  429  2020 1B                        aba
  430  2021 B7425D                    staa            tot_pos         ;se carga la variable con el total de posiciones atacables
  431                 
  432                 * DEFINIR BARCOS P1
  433  2024 B6425C                    ldaa            cant_shi
  434  2027 36                        psha                            ;se envía cantidad de cargueros
  435  2028 B6425B                    ldaa            cant_sub
  436  202B 36                        psha                            ;se envía cantidad de submarinos
  437  202C CE5000                    ldx             #p_board
  438  202F 3C                        pshx                            ;se envía el inicio del tablero de P1
  439  2030 BD210C                    jsr             setarmy
  440  2033                           %CLRST          4
  441                 
  442                 * DEFINIR BARCOS P2
  443  2037 B6425C                    ldaa            cant_shi
  444  203A 36                        psha                            ;se envía cantidad de cargueros
  445  203B B6425B                    ldaa            cant_sub
  446  203E 36                        psha                            ;se envía cantidad de submarinos
  447  203F CE5000                    ldx             #p_board        ;se toma la dirección al tablero de P1
  448  2042 C624                      ldab            #ARRAY_L
  449  2044 3A                        abx                             ;se desfasa al tablero de P2
  450  2045 3C                        pshx                            ;se envía el inicio del tablero de P2
  451  2046 BD210C                    jsr             setarmy
  452  2049                           %CLRST          4
  453                 
  454                 * ENVIAR MENSAJE DE INICIO
  455  204D CE42D8                    ldx             #play
  456  2050 BD2914                    jsr             show
  457                 
  458  2053           main            EQU             *
  459                 * ELEGIR JUGADOR
  460  2053 BD285F                    jsr             whoplays        ;se recibirá en AccA el jugador a atacar a continuación
  461  2056 B74258                    staa            player          ;se habilita la siguiente jugada
  462                 
  463                 * ENVIAR TABLERO DE JUGADOR A ATACAR A DISPLAY
  464  2059 CE5000                    ldx             #p_board
  465  205C 3C                        pshx                            ;se envía el inicio de las matrices de tableros
  466  205D B64258                    ldaa            player
  467  2060 36                        psha                            ;se envía el jugador atacado
  468  2061 CE5F00                    ldx             #display
  469  2064 3C                        pshx                            ;se envía la matriz de display (destino a copiar)
  470  2065 8624                      ldaa            #ARRAY_L
  471  2067 36                        psha                            ;se envía el tamaño de la matriz tablero
  472  2068 BD273B                    jsr             mirror          ;se envía el tablero del jugador atacado al display
  473  206B                           %CLRST          6
  474                 
  475                 * INGRESAR POSICIÓN A ATACAR
  476  2071 BD2874                    jsr             input           ;se llama a la subrutina de interfaz de usuario
  477  2074 B74259                    staa            letra_p         ;se recibe en AccA la letra jugada (fila) y en AccB el número (columna)
  478  2077 F7425A                    stab            num_p           ;se guarda la jugada
  479                 
  480                 * VERIFICAR QUE NO SEA POSICIÓN DE BARCO YA ATACADA
  481  207A B64259                    ldaa            letra_p
  482  207D 36                        psha                            ;se envía la letra jugada
  483  207E F6425A                    ldab            num_p
  484  2081 37                        pshb                            ;se envía el número jugado
  485  2082 CE4284                    ldx             #hitlist
  486  2085 3C                        pshx                            ;se envía la posición del primer arreglo de barcos tocados
  487  2086 B64258                    ldaa            player
  488  2089 36                        psha                            ;se envía el jugador a atacar
  489  208A BD27C6                    jsr             play_src        ;se recibirá el carry en 1 si la posición corresponde a un barco ya atacado
  490  208D                           %CLRST          5               ;se limpia el stack
  491  2092 25BF                      bcs             main            ;si la posición ya fue jugada, se pierde el turno y pasa al siguiente
  492                 
  493                 * MANDAR QUE JUGADOR ESTÁ JUGANDO AL DISPLAY
  494  2094 B64258                    ldaa            player
  495  2097 36                        psha                            ;se envía el jugador que está siendo atacado
  496  2098 BD2A1B                    jsr             turn
  497  209B                           %CLRST          1
  498                 
  499                 * BUSCAR EL BYTE ATACADO EN EL TABLERO DEL JUGADOR ATACADO
  500  209C B64259                    ldaa            letra_p
  501  209F 36                        psha                            ;se envía le letra jugada
  502  20A0 F6425A                    ldab            num_p
  503  20A3 37                        pshb                            ;se envía el número jugado
  504  20A4 CE5000                    ldx             #p_board
  505  20A7 3C                        pshx                            ;se envía la dirección de inicio de los arreglos de tablero
  506  20A8 F64258                    ldab            player
  507  20AB 37                        pshb                            ;se envía el jugador a atacar
  508  20AC BD2764                    jsr             fetchpos
  509  20AF                           %CLRST          4               ;se limpia el stack
  510  20B3 32                        pula                            ;se toma del stack el dato del byte jugado
  511                 
  512                 * ATACAR
  513  20B4 CE4284                    ldx             #hitlist
  514  20B7 3C                        pshx                            ;se envía inicio del arreglo de barcos atacados
  515  20B8 36                        psha                            ;se envía el byte a jugado
  516  20B9 B64259                    ldaa            letra_p
  517  20BC 36                        psha                            ;se envía le letra jugada
  518  20BD F6425A                    ldab            num_p
  519  20C0 37                        pshb                            ;se envía el número jugado
  520  20C1 CE5000                    ldx             #p_board
  521  20C4 3C                        pshx                            ;se envía la dirección de inicio de los arreglos de tablero
  522  20C5 F64258                    ldab            player
  523  20C8 37                        pshb                            ;se envía el jugador a atacar
  524  20C9 BD247C                    jsr             gameplay
  525  20CC                           %CLRST          8               ;se limpia el stack
  526                 
  527                 * ACTUALIZAR DISPLAY CON LA POSICIÓN YA ATACADA
  528  20D4 CE5000                    ldx             #p_board
  529  20D7 3C                        pshx                            ;se envía el inicio de las matrices de tableros
  530  20D8 B64258                    ldaa            player
  531  20DB 36                        psha                            ;se envía el jugador atacado
  532  20DC CE5F00                    ldx             #display
  533  20DF 3C                        pshx                            ;se envía la matriz de display (destino a copiar)
  534  20E0 8624                      ldaa            #ARRAY_L
  535  20E2 36                        psha                            ;se envía el tamaño de la matriz tablero
  536  20E3 BD273B                    jsr             mirror          ;se envía el tablero del jugador atacado al display
  537  20E6                           %CLRST          6
  538                 
  539                 * CONTAR BARCOS ATACADOS A VER SI EL JUGADOR GANÓ               
  540  20EC CE4284                    ldx             #hitlist
  541  20EF 3C                        pshx                            ;se envía la posición del primer arreglo de barcos tocados
  542  20F0 B64258                    ldaa            player
  543  20F3 36                        psha                            ;se envía el jugador a atacar
  544  20F4 BD27F9                    jsr             play_cnt
  545  20F7                           %CLRST          2
  546  20F9 32                        pula                            ;se recibe la cantidad de bytes contados
  547  20FA B1425D                    cmpa            tot_pos         
  548  20FD 2703                      beq             end_game        ;si se llegó al máximo de barcos, se termina el juego
  549                 
  550  20FF 7E2053                    jmp             main
  551                 
  552                 * MANDAR MENSAJE A DISPLAY DE QUIÉN GANÓ
  553  2102           end_game        EQU             *
  554  2102 B64258                    ldaa            player
  555  2105 36                        psha
  556  2106 BD29FD                    jsr             winner
  557  2109                           %CLRST          1
  558                 
  559  210A           end_loop        EQU             *
  560  210A 20FE                      bra             end_loop
  561                 
  562                 **************
  563                 * SUBRUTINES *
  564                 **************
  565                 
  566                 *--------------------------------------------
  567                 * setarmy: subrutina para definir los barcos
  568                 *          de cada usuario
  569                 *
  570                 * parametros: Push cantidad de cargueros
  571                 *             Push cantidad de submarinos
  572                 *             Push direccion matriz tablero
  573                 *--------------------------------------------
  574                 
  575  0003           CH_TYPE         EQU             3
  576                 
  577  0002           SA_SIZE         EQU             2
  578  0064           N_PR            EQU             100
  579  0004           N_AUX           EQU             4
  580                 
  581  0000           SA_FIL          EQU             0
  582  0001           SA_COL          EQU             1
  583  0002           SA_CARG         EQU             2
  584  0003           SA_CONT         EQU             3
  585  0004           SA_TOT          EQU             4
  586  000D           SA_MAT          EQU             13
  587  000F           SA_CSUB         EQU             15
  588  0010           SA_CSHI         EQU             16
  589                 
  590  0040           BY_SUB          EQU             01000000b
  591  0080           BY_SHI          EQU             10000000b
  592                 
  593  210C           setarmy         EQU             *
  594                 
  595                 * back up de registros
  596  210C 36                        psha
  597  210D 37                        pshb
  598  210E 3C                        pshx
  599  210F 183C                      pshy
  600                 
  601                 * variables locales
  602  2111 36                        psha
  603  2112 36                        psha
  604  2113 36                        psha
  605  2114 36                        psha
  606  2115 36                        psha
  607                 
  608                 * inializo el framepointer
  609  2116 1830                      tsy
  610                 
  611                 * inicializo los contadores
  612  2118 186F03                    clr             SA_CONT,Y
  613  211B 186F02                    clr             SA_CARG,Y
  614  211E 18A60F                    ldaa            SA_CSUB,Y
  615  2121 18E610                    ldab            SA_CSHI,Y
  616  2124 1B                        aba
  617  2125 18A704                    staa            SA_TOT,Y
  618                 
  619                 * inicializo arreglos
  620  2128 CE42DD                    ldx             #arry_pr
  621  212B 86C8                      ldaa            #N_PR*SA_SIZE
  622  212D C600                      ldab            #0
  623  212F BD29F2                    jsr             clrarray
  624                 
  625  2132                           %CLR_AUX
  626                 
  627                 * termine de entrar los barcos?
  628  213C 18A603    sa_check        ldaa            SA_CONT,Y
  629  213F 18A104                    cmpa            SA_TOT,Y
  630  2142 2603                      bne             sa_show
  631  2144                           %GOTO           sa_end  
  632                 
  633                 * display mensaje para indicar barco
  634  2147 18A10F    sa_show         cmpa            SA_CSUB,Y
  635  214A 240C                      bhs             show_shi                ;me fijo que tipod e barco es para elegir
  636  214C CE43AD    show_sub        ldx             #msg_sub                ;uno u otro string
  637  214F 8605                      ldaa            #5
  638  2151 18E603                    ldab            SA_CONT,Y
  639  2154 3D                        mul
  640  2155 3A                        abx
  641  2156 200F                      bra             show_jmp
  642  2158 CE43C6    show_shi        ldx             #msg_shi
  643  215B 18A603                    ldaa            SA_CONT,Y
  644  215E 18E60F                    ldab            SA_CSUB,Y               ;cambio el corrimiento adentro de los strings
  645  2161 10                        sba
  646  2162 16                        tab
  647  2163 8605                      ldaa            #5
  648  2165 3D                        mul
  649  2166 3A                        abx
  650  2167 BD2914    show_jmp        jsr             show                    ;y luego imprimo el mensaje
  651  216A                           %EXPECT         B_reset
  652                 
  653                 * espera ingreso de coordenada
  654  2174 BD2874    sa_again        jsr             input                   ;espero una coordenada
  655                 
  656  2177 18A700                    staa            SA_FIL,Y                ;la guardo en memoria temporal
  657  217A 18E701                    stab            SA_COL,Y
  658                 
  659                 * verifico que no sea una posicion prohibida
  660  217D                           %IS_PROH                                ;me fijo si esta en la lista de posiciones prohibidas
  661  218C 25E6                      bcs             sa_again
  662                 
  663                 * me fijo que tipo de barco se ingresa
  664  218E 36                        psha
  665  218F 18A603                    ldaa            SA_CONT,Y
  666  2192 18A10F                    cmpa            SA_CSUB,Y
  667  2195 32                        pula
  668  2196 2503                      blo             sa_sub                  ;segun que tipo de barco manejo distinto
  669  2198                           %GOTO           sa_shi                  ;porque el carguero tiene dos partes
  670                 
  671                 * escribo en matriz el submarino
  672  219B           sa_sub          %PROH_POS                               ;si es submarino agrego a prohibida la posicion
  673  21B4                           %PROH_PER                               ;y tambien prohibo la periferia del submarino
  674  221F                           %SET_POS        BY_SUB                  ;grabo ese barco en la matriz
  675  2238 186C03                    inc             SA_CONT,Y
  676  223B                           %REFRESH                                ;y luego refresco la pantalla para que lo vea el jugador
  677  2256                           %GOTO           sa_check
  678                 
  679  2259 186D02    sa_shi          tst             SA_CARG,Y               ;si es carguero me tengo que fijar
  680  225C 2703                      beq             sa_part1                ;que parte del carguero es
  681  225E                           %GOTO           sa_part2
  682                 
  683  2261           sa_part1        %SET_AUX                                ;creo arreglo auxiliar con posibles partes 2
  684                                 
  685  22A4 183C                      pshy
  686  22A6 18CE43A5                  ldy             #arry_aux
  687  22AA C604                      ldab            #N_AUX
  688  22AC 5A        sa_loop         decb
  689  22AD 2B35                      bmi             sa_notok                ;me fijo que las auxiliares sean validas
  690                 
  691                 * comprobar que sea valida
  692  22AF 18A600                    ldaa            0,Y                     ;y tambien que esten en el tablero
  693  22B2 810A                      cmpa            #MIN_FIL
  694  22B4 2528                      blo             sa_nval
  695  22B6 810F                      cmpa            #MAX_FIL
  696  22B8 2224                      bhi             sa_nval
  697  22BA 18A601                    ldaa            1,Y
  698  22BD 8101                      cmpa            #MIN_COL
  699  22BF 251D                      blo             sa_nval
  700  22C1 8106                      cmpa            #MAX_COL
  701  22C3 2219                      bhi             sa_nval
  702                         
  703  22C5 37                        pshb
  704  22C6 18A600                    ldaa            0,Y
  705  22C9 18E601                    ldab            1,Y
  706  22CC                           %IS_PROH
  707  22DB 33                        pulb
  708  22DC 2415                      bcc             sa_ok
  709  22DE 1808      sa_nval         iny
  710  22E0 1808                      iny
  711  22E2 20C8                      bra             sa_loop
  712                 
  713  22E4 1838      sa_notok        puly
  714  22E6                           %CLR_AUX
  715  22F0                           %GOTO           sa_again
  716                 
  717  22F3 1838      sa_ok           puly
  718  22F5 18A600                    ldaa            SA_FIL,Y
  719  22F8 18E601                    ldab            SA_COL,Y
  720  22FB                           %PROH_POS                               ;prohibo la posicion de la parte uno
  721  2314 186C02                    inc             SA_CARG,Y
  722  2317                           %SET_POS        BY_SHI                  ;grabo la posicion de la parte uno
  723  2330                           %GOTO           sa_again
  724  2333 CE43A5    sa_part2        ldx             #arry_aux               ;me fijo que ingreso una parte dos permitida
  725  2336 8604                      ldaa            #N_AUX
  726  2338 4A        sa_verf         deca
  727  2339 2A03                      bpl             sa_chk          
  728  233B                           %GOTO           sa_again
  729  233E E600      sa_chk          ldab            0,X
  730  2340 18E100                    cmpb            SA_FIL,Y
  731  2343 2609                      bne             sa_not
  732  2345 E601                      ldab            1,X
  733  2347 18E101                    cmpb            SA_COL,Y
  734  234A 2602                      bne             sa_not
  735  234C 2004                      bra             sa_good
  736  234E 08        sa_not          inx
  737  234F 08                        inx
  738  2350 20E6                      bra             sa_verf
  739                 
  740  2352 183C      sa_good         pshy
  741  2354 18CE43A5                  ldy             #arry_aux
  742  2358 C604                      ldab            #4
  743  235A 5A        sa_loop2        decb
  744  235B 2B23                      bmi             sa_done
  745  235D 37                        pshb
  746  235E 18A600                    ldaa            0,Y
  747  2361 18E601                    ldab            1,Y
  748  2364                           %PROH_POS                               ;prohibo la periferia de la parte uno
  749  237D 33                        pulb
  750  237E 20DA                      bra             sa_loop2
  751                 
  752  2380 1838      sa_done         puly
  753  2382 18A600                    ldaa            SA_FIL,Y
  754  2385 18E601                    ldab            SA_COL,Y
  755  2388                           %PROH_POS                               ;prohibo la parte dos
  756  23A1                           %PROH_PER                               ;prohibo la periferia de la parte dos
  757  240C                           %SET_POS        BY_SHI
  758  2425 186C03                    inc             SA_CONT,Y
  759  2428 186F02                    clr             SA_CARG,Y
  760  242B                           %CLR_AUX
  761  2435                           %REFRESH                                ;refresco display para visualizar al jugador
  762  2450                           %GOTO           sa_check
  763                 
  764                 * libero variables temporales
  765  2453           sa_end          %FIX_ARRY                               ;correccion en matrices por visualizacion
  766  2464                           %CLS                                    ;preliminar de la flota del jugador
  767  2471 32                        pula
  768  2472 32                        pula
  769  2473 32                        pula
  770  2474 32                        pula
  771  2475 32                        pula
  772                 
  773                 * restore de registros
  774  2476 1838                      puly
  775  2478 38                        pulx
  776  2479 33                        pulb
  777  247A 32                        pula
  778                 
  779  247B 39                        rts
  780                 
  781                 *=======================================================================
  782                 * subrutina gameplay
  783                 * Función: Determina si la posición jugada en el juego de batalla naval
  784                 *          para Wookie FX fue "agua", "submarion" o "carguero", y toma 
  785                 *          la decisión de qué hacer al respecto.
  786                 * Recibe: - Dirección arreglo auxiliar de barcos
  787                 *         - Byte a jugar.
  788                 *         - FILA del array (En HEX, de $0A (fil.0) en adelante)
  789                 *         - COLUMNA del array (en HEX)
  790                 *         - Dirección de comienzo del arreglo (2 bytes)
  791                 *         - Número de arreglo (de 0 en adelante) (número de jugador)
  792                 *       TODO POR STACK.
  793                 * Devuelve: parámetro jugado en posición correspondiente.
  794                 * Requiere: 
  795                 *=======================================================================
  796  247C           gameplay        EQU             *
  797  247C                           %BACKUP
  798                                 
  799  2481 30                        tsx                             ;se usa el IX como frame pointer
  800  2482 A60D                      ldaa            13,x            ;se carga en AccA el byte a analizar
  801  2484 84C0                      anda            #11000000b      ;se enmascan los bits 0 a 5, para analizar los más significativos
  802                 
  803  2486           gp_water        EQU             *
  804  2486 2620                      bne             gp_sub          ;se estudia si era agua
  805  2488                           %WRITEPOS       #WATER          ;se cambia el color en el tablero
  806  24A2                           %RESTORE
  807  24A7 39                        rts
  808                 
  809  24A8           gp_sub          EQU             *
  810  24A8 8140                      cmpa            #01000000b      ;se estudia si era un submarino
  811  24AA 2636                      bne             gp_shi_r
  812  24AC                           %WRITEPOS       #SUNK_SUB       ;se cambia el color en el tablero
  813  24C6                           %PLAY_WRT                       ;se agraga la posición al array de barcos atacados
  814  24DC                           %RESTORE
  815  24E1 39                        rts
  816                 
  817  24E2           gp_shi_r        EQU             *               ;si no era ninguno de los anteriores, es un carguero
  818  24E2 E60B                      ldab            11,x
  819  24E4 C106                      cmpb            #MAX_C
  820  24E6 276D                      beq             gp_shi_l        ;si está en el borde derecho, se continúa
  821  24E8 E60C                      ldab            12,x
  822  24EA 37                        pshb                            ;se envía la letra (fila)
  823  24EB E60B                      ldab            11,x
  824  24ED 5C                        incb                            ;se avanza a la derecha
  825  24EE 37                        pshb                            ;se envía el num (columna)
  826  24EF 1AEE0E                    ldy             14,x
  827  24F2 183C                      pshy                            ;se envía el inicio del arreglo de barcos atacados
  828  24F4 E608                      ldab            8,x
  829  24F6 37                        pshb                            ;se envía el jugador atacado
  830  24F7 BD27C6                    jsr             play_src        ;se busca la posición de la derecha
  831  24FA                           %CLRST          5
  832  24FF 2454                      bcc             gp_shi_l        ;si no había barco atacado en la derecha, se busca la izquierda
  833  2501                           %WRITEPOS       #SUNK_SHI       
  834  251B 6C0B                      inc             11,x
  835  251D                           %WRITEPOS       #SUNK_SHI       ;se "hunde" a TODO el carguero
  836  2537 6A0B                      dec             11,x            ;se recupera el dato
  837  2539                           %PLAY_WRT                       ;se agrega la posición al array de barcos atacados
  838  254F                           %RESTORE
  839  2554 39                        rts
  840                 
  841  2555           gp_shi_l        EQU             *
  842  2555 E60B                      ldab            11,x
  843  2557 C101                      cmpb            #MIN_C
  844  2559 276D                      beq             gp_shi_u        ;si está en el borde izquierdo, se continúa
  845  255B E60C                      ldab            12,x
  846  255D 37                        pshb                            ;se envía la letra (fila)
  847  255E E60B                      ldab            11,x
  848  2560 5A                        decb                            ;se retrocede a la izquierda
  849  2561 37                        pshb                            ;se envía el número (columna)
  850  2562 1AEE0E                    ldy             14,x
  851  2565 183C                      pshy                            ;se envía el inicio del arreglo de barcos atacados
  852  2567 E608                      ldab            8,x
  853  2569 37                        pshb                            ;se envía el jugador atacado
  854  256A BD27C6                    jsr             play_src        ;se busca la posición de la izquierda
  855  256D                           %CLRST          5
  856  2572 2454                      bcc             gp_shi_u        ;si no había barco atacado a la izquierda, se busca arriba
  857  2574                           %WRITEPOS       #SUNK_SHI       
  858  258E 6A0B                      dec             11,x
  859  2590                           %WRITEPOS       #SUNK_SHI       ;se "hunde" a TODO el carguero
  860  25AA 6C0B                      inc             11,x            ;se recupera el dato
  861  25AC                           %PLAY_WRT                       ;se agrega la posición al array de barcos atacados
  862  25C2                           %RESTORE
  863  25C7 39                        rts
  864                 
  865  25C8           gp_shi_u        EQU             *
  866  25C8 E60C                      ldab            12,x
  867  25CA C10A                      cmpb            #MIN_F
  868  25CC 276D                      beq             gp_shi_d        ;si está en el borde superior, se continúa
  869  25CE E60C                      ldab            12,x
  870  25D0 5A                        decb                            ;se va a la posición de arriba
  871  25D1 37                        pshb                            ;se envía la letra (fila)
  872  25D2 E60B                      ldab            11,x
  873  25D4 37                        pshb                            ;se envía el num (columna)
  874  25D5 1AEE0E                    ldy             14,x
  875  25D8 183C                      pshy                            ;se envía el inicio del arreglo de barcos atacados
  876  25DA E608                      ldab            8,x
  877  25DC 37                        pshb                            ;se envía el jugador atacado
  878  25DD BD27C6                    jsr             play_src        ;se busca la posición de arriba
  879  25E0                           %CLRST          5
  880  25E5 2454                      bcc             gp_shi_d        ;si no había barco atacado arriba, se busca abajo
  881  25E7                           %WRITEPOS       #SUNK_SHI       
  882  2601 6A0C                      dec             12,x
  883  2603                           %WRITEPOS       #SUNK_SHI       ;se "hunde" a TODO el carguero
  884  261D 6C0C                      inc             12,x            ;se recupera el dato
  885  261F                           %PLAY_WRT                       ;se agrega la posición al array de barcos atacados
  886  2635                           %RESTORE
  887  263A 39                        rts
  888                 
  889  263B           gp_shi_d        EQU             *
  890  263B E60C                      ldab            12,x
  891  263D C10F                      cmpb            #MAX_F
  892  263F 276D                      beq             gp_shi_h        ;si está en el borde inferior, se continúa
  893  2641 E60C                      ldab            12,x
  894  2643 5C                        incb                            ;se va a la posición de abajo
  895  2644 37                        pshb                            ;se envía la letra (fila)
  896  2645 E60B                      ldab            11,x
  897  2647 37                        pshb                            ;se envía el num (columna)
  898  2648 1AEE0E                    ldy             14,x
  899  264B 183C                      pshy                            ;se envía el inicio del arreglo de barcos atacados
  900  264D E608                      ldab            8,x
  901  264F 37                        pshb                            ;se envía el jugador atacado
  902  2650 BD27C6                    jsr             play_src        ;se busca la posición de abajo
  903  2653                           %CLRST          5
  904  2658 2454                      bcc             gp_shi_h        ;si no había barco atacado abajo, el carguero está tocado
  905  265A                           %WRITEPOS       #SUNK_SHI       
  906  2674 6C0C                      inc             12,x
  907  2676                           %WRITEPOS       #SUNK_SHI       ;se "hunde" a TODO el carguero
  908  2690 6A0C                      dec             12,x            ;se recupera el dato
  909  2692                           %PLAY_WRT                       ;se agrega la posición al array de barcos atacados
  910  26A8                           %RESTORE
  911  26AD 39                        rts
  912                 
  913  26AE           gp_shi_h        EQU             *
  914  26AE                           %WRITEPOS       #HIT            ;se marca al carguero como tocado
  915  26C8                           %PLAY_WRT                       ;se agrega la posición al array de barcos atacados
  916  26DE                           %RESTORE
  917  26E3 39                        rts
  918                 
  919                 *==========================================================================
  920                 * subrutina def_ships
  921                 * Función: Determina los valores de cargueros y submarinos a utilizar.
  922                 * Recibe: Nada
  923                 * Devuelve: Cantidad de cargueros y submarinos en memorias correspondientes.
  924                 * Requiere:
  925                 *==========================================================================
  926  26E4           def_ships       EQU             *
  927  26E4                           %BACKUP
  928                 
  929  26E9           wait_nsu        EQU             *
  930  26E9 CE42CE                    ldx             #subm
  931  26EC BD2914                    jsr             show
  932                 
  933  26EF BD2928                    jsr             read_kb
  934  26F2 4D                        tsta
  935  26F3 2BF4                      bmi             wait_nsu
  936  26F5 36                        psha
  937  26F6                           %EXPECT         B_fire
  938  2700 32                        pula
  939                 
  940  2701 CE4265                    ldx             #kb_value
  941  2704 16                        tab
  942  2705 3A                        abx
  943  2706 A600                      ldaa            0,x             ;se obtiene el valor ingresado ya codificado
  944                 
  945  2708 8105                      cmpa            #SUB            ;se controla que no sea menor al máximo de submarinos
  946  270A 22DD                      bhi             wait_nsu
  947  270C B7425B                    staa            cant_sub        ;se guarda la cantidad de submarinos
  948                 
  949  270F           wait_nsh        EQU             *
  950  270F CE42D3                    ldx             #carg
  951  2712 BD2914                    jsr             show
  952                 
  953  2715 BD2928                    jsr             read_kb
  954  2718 4D                        tsta
  955  2719 2BF4                      bmi             wait_nsh
  956  271B 36                        psha
  957  271C                           %EXPECT         B_fire
  958  2726 32                        pula
  959                 
  960  2727 CE4265                    ldx             #kb_value
  961  272A 16                        tab
  962  272B 3A                        abx
  963  272C A600                      ldaa            0,x             ;se obtiene el valor ingresado ya codificado
  964                 
  965  272E 8104                      cmpa            #SHI            ;se controla que no sea menor al máximo de submarinos
  966  2730 22DD                      bhi             wait_nsh
  967  2732 B7425C                    staa            cant_shi        ;se guarda la cantidad de submarinos
  968                 
  969  2735                           %RESTORE
  970  273A 39                        rts
  971                 
  972                 *====================================================================================
  973                 * Subrutina "MIRROR"
  974                 *
  975                 * Descripción:  Esta subrutina copia el contenido de las posiciones de un array fuente
  976                 *               a un espacio de memoria destino.
  977                 * Parámetros de entrada:
  978                 *               - Dirección de comienzo de array FUENTE
  979                 *               - Número de arreglo contenido en otro arreglo (número de jugador)(0 en adelante)
  980                 *               - Dirección de DESTINO de la copia 
  981                 *               - Número de posiciones a copiar (un byte, hasta 255 posiciones.)
  982                 *               - Número de arreglo (de 0 en adelante) (número de jugador)
  983                 *
  984                 *       Todos los parámetros se reciben por stack en el orden indicado. 
  985                 *       Se destruirá el dato de la dirección del array de origen.
  986                 *               
  987                 * Parámetros de salida: NINGUNO
  988                 *       
  989                 *
  990                 * Consideraciones:
  991                 *               - Luego de invocada, se debe normalizar el stack en 6 posiciones
  992                 *
  993                 *====================================================================================
  994                 
  995  273B           mirror          EQU             *       
  996                         
  997  273B                           %BACKUP
  998  2740 30                        tsx                             ;creo frame pointer
  999  2741 A60B                      ldaa            11,x            ;cargo número de jugador
 1000  2743 E608                      ldab            8,x             ;cargo longitud de la copia (del array a copiar)
 1001  2745 3D                        mul                             ;obtengo offset de jugador
 1002  2746 E30C                      addd            12,x            ;sumo offset de jugador
 1003  2748 ED0C                      std             12,x            ;guardo la dirección con offset del array fuente
 1004                 
 1005  274A A608                      ldaa            8,x             ;cargo longitud de copia en contador
 1006  274C 2710                      beq             mi_end          ;si es cero, vuelvo desde subrutina
 1007  274E 1AEE09                    ldy             9,x             ;cargo índice a destino de la copia.
 1008  2751 EE0C                      ldx             12,x            ;cargo índice a array origen de copia.
 1009                 
 1010  2753           mi_loop         EQU             *
 1011                 
 1012  2753 E600                      ldab            0,x             ;cargo byte a copiar
 1013  2755 18E700                    stab            0,y             ;copio byte en destino
 1014  2758 08                        inx                             ;siguiente byte
 1015  2759 1808                      iny                             ;siguiente byte
 1016  275B 4A                        deca                            ;decremento contador
 1017  275C 26F5                      bne             mi_loop
 1018                 
 1019  275E           mi_end          EQU             *
 1020                 
 1021  275E                           %RESTORE
 1022                         
 1023  2763 39                        rts     
 1024                                 
 1025                                                 
 1026                 *====================================================================================
 1027                 * Subrutina "FETCHPOS"
 1028                 *
 1029                 * Descripción:  La subrutina busca en un array de tres dimensiones una 
 1030                 *               determinada posición, y devuelve el byte que se encuentra
 1031                 *               en esa posición por stack. Subrutina limitada a longitud
 1032                 *               de elementos del array de un byte.
 1033                 *
 1034                 * Parámetros de entrada:
 1035                 *               - FILA del array (En HEX, de $0A (fil.0) en adelante)
 1036                 *               - COLUMNA del array (en HEX)
 1037                 *               - Dirección de comienzo del arreglo (2 bytes)
 1038                 *               - Número de arreglo (de 0 en adelante) (número de jugador)
 1039                 *
 1040                 *       Todos los parámetros se reciben por stack en el orden indicado.
 1041                 *       Se destruirá el dato del índice al arreglo.
 1042                 *               
 1043                 * Parámetros de salida:
 1044                 *               - Byte encontrado en esa posición (se devuelve por stack)
 1045                 *
 1046                 *
 1047                 * Consideraciones:
 1048                 *               - Antes de recuperar el byte en stack se debe normalizar el mismo
 1049                 *                 en 4 posiciones (4 bytes)
 1050                 *               - Requiere definición de constante "ARRAY_L"
 1051                 *
 1052                 *====================================================================================
 1053                 
 1054  2764           fetchpos        EQU             *
 1055                 
 1056  2764                           %BACKUP
 1057  2769 30                        tsx                             ;creo frame pointer
 1058  276A A608                      ldaa            8,x             ;cargo numero de jugador
 1059  276C C624                      ldab            #ARRAY_L        ;cargo longitud del arreglo (MAX 255 bytes)
 1060  276E 3D                        mul                             ;obtengo offset de jugador
 1061  276F E309                      addd            9,x             ;sumo offset de jugador a top of array
 1062  2771 ED09                      std             9,x             ;obtengo direccion al arreglo del jugador
 1063                 
 1064  2773 A60C                      ldaa            12,x            ;cargo coordenada letra (FILA)
 1065  2775 C60A                      ldab            #NORM           ;cargo valor de normalización de filas
 1066  2777 10                        sba                             ;obtengo numero de fila
 1067  2778 C606                      ldab            #COL            ;cargo longitud de fila
 1068  277A 3D                        mul                             ;obtengo offset de fila
 1069  277B E309                      addd            9,x             ;sumo offset de fila a la dirección del arreglo del jugador
 1070  277D ED09                      std             9,x             ;obtengo dirección a la fila que se desea
 1071                 
 1072  277F E60B                      ldab            11,x            ;cargo coordenada (offset) de columna
 1073  2781 5A                        decb                            ;normalizo offset de columna
 1074  2782 4F                        clra                            ;borro AccA para tener el valor de AccB en AccD
 1075  2783 E309                      addd            9,x             ;sumo offset de columna a la dirección temporal
 1076  2785 ED09                      std             9,x             ;guardo en stack la dirección del byte a consultar
 1077                 
 1078  2787 1AEE09                    ldy             9,x             ;cargo en IY la dirección del byte que se desea obtener
 1079  278A 18A600                    ldaa            0,y             ;cargo el byte a devolver en AccA
 1080  278D A70C                      staa            12,x            ;guardo el byte a devolver en stack
 1081  278F                           %RESTORE
 1082                                 
 1083  2794 39                        rts
 1084                                 
 1085                                 
 1086                 
 1087                 *====================================================================================
 1088                 * Subrutina "WRITEPOS"
 1089                 *
 1090                 * Descripción:  La subrutina busca en un array de tres dimensiones una 
 1091                 *               determinada posición, y escribe en la misma un byte de
 1092                 *               datos que será recibido como parámetro de entrada por stack.
 1093                 *
 1094                 * Parámetros de entrada:
 1095                 *               - BYTE a escribir en la posición indicada
 1096                 *               - FILA del array (En HEX, de $0A (fil.0) en adelante)
 1097                 *               - COLUMNA del array (en HEX)
 1098                 *               - Dirección de comienzo del arreglo (2 bytes)
 1099                 *               - Número de arreglo (de 0 en adelante) (número de jugador)
 1100                 *
 1101                 *       Todos los parámetros se reciben por stack en el orden indicado. 
 1102                 *       Se destruirá el dato del índice al arreglo.
 1103                 *               
 1104                 * Parámetros de salida: NINGUNO
 1105                 *       
 1106                 *
 1107                 * Consideraciones:
 1108                 *               - Luego de invocada, se debe normalizar el stack en 6 posiciones
 1109                 *               - Requiere definición de constante "ARRAY_L"
 1110                 *
 1111                 *====================================================================================
 1112                 
 1113  2795           writepos        EQU             *
 1114                 
 1115  2795                           %BACKUP
 1116  279A 30                        tsx                             ;creo frame pointer
 1117  279B A608                      ldaa            8,x             ;cargo numero de jugador
 1118  279D C624                      ldab            #ARRAY_L        ;cargo longitud del arreglo (MAX 255 bytes)
 1119  279F 3D                        mul                             ;obtengo offset de jugador
 1120  27A0 E309                      addd            9,x             ;sumo offset de jugador a top of array
 1121  27A2 ED09                      std             9,x             ;obtengo direccion al arreglo del jugador
 1122                 
 1123  27A4 A60C                      ldaa            12,x            ;cargo coordenada letra (FILA)
 1124  27A6 C60A                      ldab            #NORM           ;cargo valor de normalización de filas
 1125  27A8 10                        sba                             ;obtengo numero de fila
 1126  27A9 C606                      ldab            #COL            ;cargo longitud de fila
 1127  27AB 3D                        mul                             ;obtengo offset de fila
 1128  27AC E309                      addd            9,x             ;sumo offset de fila a la dirección del arreglo del jugador
 1129  27AE ED09                      std             9,x             ;obtengo dirección a la fila que se desea
 1130                 
 1131  27B0 E60B                      ldab            11,x            ;cargo coordenada (offset) de columna
 1132  27B2 5A                        decb                            ;normalizo offset de columna
 1133  27B3 4F                        clra                            ;borro AccA para tener el valor de AccB en AccD
 1134  27B4 E309                      addd            9,x             ;sumo offset de columna a la dirección temporal
 1135  27B6 ED09                      std             9,x             ;guardo en stack la dirección del byte a consultar
 1136                 
 1137  27B8 1AEE09                    ldy             9,x             ;cargo en IY la dirección donde se desea escribir
 1138  27BB A60D                      ldaa            13,x            ;cargo en AccA el byte que se quiere escribir en el arreglo
 1139  27BD 18A700                    staa            0,y             ;escribo el byte sobre el arreglo
 1140  27C0                           %RESTORE
 1141                                 
 1142  27C5 39                        rts
 1143                 *====================================================================================
 1144                 * Subrutina "PLAY_SRC"
 1145                 *
 1146                 * Descripción:  Esta subrutina busca dos bytes consecutivos (posicion jugada) dentro de un arreglo.
 1147                 *               El valor $00 podrá estar en el array solo como terminador
 1148                 * Parámetros de entrada:
 1149                 *               - Byte1 a buscar (en este caso, n° fila)
 1150                 *               - Byte2 a buscar (en este caso, n° columna)
 1151                 *               - Dirección de inicio del array
 1152                 *               - Número de jugador (0 o mayor)
 1153                 *
 1154                 *       Todos los parámetros se reciben por stack en el orden indicado. 
 1155                 *               
 1156                 * Parámetros de salida:
 1157                 *               - Carry en 1, si se encontró la posición.
 1158                 *       
 1159                 *
 1160                 * Consideraciones:
 1161                 *               - Luego de invocada, se debe normalizar el stack en 5 posiciones antes de
 1162                 *                 recuperar el parámetro de salida.
 1163                 *
 1164                 *====================================================================================
 1165                 
 1166  27C6           play_src        EQU             *               
 1167                                         
 1168  27C6                           %BACKUP
 1169  27CB 30                        tsx                             ;creo frame pointer
 1170  27CC A608                      ldaa            8,x             ;cargo número de array (jugador)
 1171  27CE C61B                      ldab            #HITSIZE        ;cargo tamaño de array de 1 jugador
 1172  27D0 3D                        mul                             ;obtengo offset de jugador
 1173  27D1 E309                      addd            9,x             ;sumo el offset de jugador al puntero al array
 1174  27D3 188F                      xgdy                            ;obtengo puntero al array del jugador deseado
 1175                 
 1176  27D5           ps_loop         EQU             *
 1177                 
 1178  27D5 18A600                    ldaa            0,y             ;cargo byte1 a comparar
 1179  27D8 2718                      beq             ps_ntfnd        ;si encontré el terminador, el valor requerido no está en el array
 1180                 
 1181  27DA A10C                      cmpa            12,x            ;comparo con el byte1 a buscar
 1182  27DC 2706                      beq             ps_next         ;si coinciden, busco el byte 2
 1183  27DE 1808                      iny                             ;me posiciono sobre siguiente byte1 a comparar
 1184  27E0 1808                      iny
 1185  27E2 20F1                      bra             ps_loop         ;vuelvo a comparar
 1186                 
 1187  27E4           ps_next         EQU             *
 1188                 
 1189  27E4 18E601                    ldab            1,y             ;cargo byte a continuación del anterior
 1190  27E7 1808                      iny                             ;me posiciono sobre siguiente byte1 a comparar
 1191  27E9 1808                      iny
 1192  27EB E10B                      cmpb            11,x            ;comparo con byte2
 1193  27ED 26E6                      bne             ps_loop         ;si no son iguales, sigo buscando
 1194  27EF 0D                        sec                             ;set del carry para informar que se encontró el valor
 1195  27F0 2001                      bra             ps_end
 1196                                         
 1197  27F2           ps_ntfnd        EQU             *
 1198                 
 1199  27F2 0C                        clc                             ;carry en 0 para informar que no se encontró el valor
 1200                 
 1201  27F3           ps_end          EQU             *
 1202                                 
 1203  27F3                           %RESTORE
 1204                 
 1205  27F8 39                        rts
 1206                 
 1207                 *====================================================================================
 1208                 * Subrutina "PLAY_CNT"
 1209                 *
 1210                 * Descripción:  Esta subrutina cuenta la cantidad de datos de dos bytes que se encuentran en una
 1211                 *               determinada zona de memoria configurada como array. Se supone que $00 no es un dato presente en dicho array, 
 1212                 *               usándose solamente como terminador del mismo.
 1213                 *
 1214                 * Parámetros de entrada:
 1215                 *               - Dirección de inicio del array
 1216                 *               - Número de jugador (0 o mayor)
 1217                 *
 1218                 *       Todos los parámetros se reciben por stack en el orden indicado. 
 1219                 *               
 1220                 * Parámetros de salida:
 1221                 *               - Cantidad de datos de dos bytes encontrados, por stack (máximo 255 datos).
 1222                 *       
 1223                 *
 1224                 * Consideraciones:
 1225                 *               - Luego de invocada, se debe normalizar el stack en 2 posiciones antes de
 1226                 *                 recuperar el parámetro de salida.
 1227                 *
 1228                 *====================================================================================
 1229                 
 1230  27F9           play_cnt        EQU             *
 1231                 
 1232  27F9                           %BACKUP
 1233  27FE 30                        tsx                             ;creo frame pointer
 1234  27FF A608                      ldaa            8,x             ;cargo número de array (jugador)
 1235  2801 C61B                      ldab            #HITSIZE        ;cargo tamaño de array de 1 jugador
 1236  2803 3D                        mul                             ;obtengo offset de jugador
 1237  2804 E309                      addd            9,x             ;sumo el offset de jugador al puntero al array
 1238  2806 188F                      xgdy                            ;obtengo puntero al array del jugador deseado
 1239  2808 4F                        clra                            ;inicializo contador
 1240                                         
 1241  2809           pc_loop         EQU             *               
 1242                                         
 1243  2809 18E600                    ldab            0,y             ;cargo byte a comparar
 1244  280C 2707                      beq             pc_end          ;si es terminador, terminé de buscar
 1245  280E 1808                      iny                             ;si no es terminador, me posiciono sobre siguiente dato de 
 1246  2810 1808                      iny                             ;2 bytes
 1247  2812 4C                        inca                            ;incremento contador
 1248  2813 20F4                      bra             pc_loop         ;vuelvo a comparar
 1249                                         
 1250  2815           pc_end          EQU             *       
 1251                                         
 1252  2815 A70A                      staa            10,x            ;devuelvo valor por stack
 1253  2817                           %RESTORE
 1254                                 
 1255  281C 39                        rts
 1256                 
 1257                 
 1258                 *====================================================================================
 1259                 * Subrutina "PLAY_WRT"
 1260                 *
 1261                 * Descripción:  Esta subrutina escribe dos bytes distintos (en este caso, la posición 
 1262                 *               jugada, compuesta de una letra y un número) en la primera posición "libre"
 1263                 *               de un array y en la siguiente. La subrutina escribirá los datos desde la primera posición con ceros
 1264                 *               que encuentre en el array, por lo que el mismo NO podrá contener el dato "$00" en ninguno
 1265                 *               de sus bytes, caso contrario la subrutina lo interpretará como vacío y sobreescribirá información. Se
 1266                 *               supone que el array tendrá por lo menos, dos posiciones libres.
 1267                 *
 1268                 * Parámetros de entrada:
 1269                 *               - Primer byte a escribir (en este caso, fila jugada)
 1270                 *               - Byte a escribir a continuación del primero (en este caso, columna jugada)
 1271                 *               - Dirección de inicio del array en el que se va a escribir
 1272                 *               - Número de jugador (0 o mayor)
 1273                 *
 1274                 *       Todos los parámetros se reciben por stack en el orden indicado. 
 1275                 *               
 1276                 * Parámetros de salida: NINGUNO
 1277                 *       
 1278                 *
 1279                 * Consideraciones:
 1280                 *               - Luego de invocada, se debe normalizar el stack en 5 posiciones
 1281                 *
 1282                 *====================================================================================
 1283                 
 1284  281D           play_wrt        EQU             *
 1285                 
 1286  281D                           %BACKUP
 1287  2822 30                        tsx                             ;creo frame pointer
 1288  2823 A608                      ldaa            8,x             ;cargo número de array (jugador)
 1289  2825 C61B                      ldab            #HITSIZE        ;cargo tamaño de array de 1 jugador
 1290  2827 3D                        mul                             ;obtengo offset de jugador
 1291  2828 E309                      addd            9,x             ;sumo el offset de jugador al puntero al array
 1292  282A 188F                      xgdy                            ;obtengo puntero al array del jugador deseado
 1293                 
 1294                 
 1295  282C           pw_loop         EQU             *
 1296                 
 1297  282C 18A600                    ldaa            0,y             ;cargo byte del array
 1298  282F 2704                      beq             pw_end          ;si es cero, entonces escribo los datos
 1299  2831 1808                      iny                             ;si no es cero, me posiciono sobre la siguiente posición
 1300  2833 20F7                      bra             pw_loop         ;vuelvo a buscar ceros
 1301                 
 1302  2835           pw_end          EQU             *
 1303                 
 1304  2835 A60C                      ldaa            12,x            ;cargo primer byte a escribir
 1305  2837 18A700                    staa            0,y             ;guardo primer byte en memoria
 1306  283A 1808                      iny                             ;me posiciono en el siguiente byte
 1307  283C A60B                      ldaa            11,x            ;cargo segundo byte a escribir
 1308  283E 18A700                    staa            0,y             ;guardo segundo byte en memoria
 1309  2841                           %RESTORE
 1310                 
 1311  2846 39                        rts
 1312                 
 1313                 ***************************************************************************************
 1314                 *Subrutina "CLRZONE"
 1315                 *Función: "borra" (guarda ceros) una determinada zona de memoria.
 1316                 *         
 1317                 *
 1318                 * Parámetros de entrada: -Dirección de comienzo de sección a borrar (por stack)
 1319                 *                        -Longitud de zona de memoria (por stack)
 1320                 *                       
 1321                 *
 1322                 * Parámetros de salida: Ninguno
 1323                 *
 1324                 * consideraciones: 
 1325                 *                  - Incluir macros "%BACKUP" y "%RESTORE".
 1326                 *                                       
 1327                 *************************************************************************************** 
 1328  2847           clrzone         EQU     *
 1329                 
 1330  2847                           %BACKUP                         ;backup de registros en stack
 1331                 
 1332  284C 30                        tsx
 1333  284D A608                      ldaa    8,x                     ;cargo contador con longitud de zona a borrar
 1334  284F EE09                      ldx     9,x                     ;cargo puntero zona de memoria a borrar
 1335  2851 D600                      ldab    $00                     ;cargo el cero
 1336  2853           clr_loop        EQU     *
 1337  2853 E700                      stab    0,x                     ;guardo caracter en posicion del array
 1338  2855 08                        inx                             ;siguiente posición     
 1339  2856 4A                        deca                            ;decremento contador
 1340  2857 26FA                      bne     clr_loop                ;si no es cero, escribo en la posición siguiente.
 1341                 
 1342  2859                           %RESTORE                        :restauro backup en registros
 1343                 
 1344  285E 39                        rts
 1345                 
 1346                 *---------------------------------------
 1347                 * WhoPlays: subrutina para ver que 
 1348                 *           jugador juega
 1349                 *---------------------------------------
 1350                 
 1351  285F           whoplays        EQU             *
 1352                 
 1353  285F BD2928    wait_ply        jsr             read_kb
 1354  2862 4D                        tsta
 1355  2863 2BFA                      bmi             wait_ply
 1356  2865 8103                      cmpa            #B_P1
 1357  2867 2708                      beq             play_p1
 1358  2869 8107                      cmpa            #B_P2
 1359  286B 26F2                      bne             wait_ply
 1360  286D 8600                      ldaa            #P1
 1361  286F 2002                      bra             ply_end
 1362                 
 1363  2871 8601      play_p1         ldaa            #P2
 1364  2873 39        ply_end         rts             
 1365                 
 1366                 *---------------------------------------
 1367                 * Input: subrutina que devuelve
 1368                 *        entrada para la batalla naval
 1369                 * AccA: Fila de la posicion jugada
 1370                 * AccB: Columna de la posicion jugada
 1371                 *---------------------------------------
 1372                 
 1373  2874           input           EQU             *
 1374                 
 1375                 * back up de registros
 1376  2874 3C                        pshx
 1377  2875 183C                      pshy
 1378                 
 1379                 * creo variables locales
 1380  2877 36                        psha
 1381  2878 36                        psha
 1382  2879 36                        psha
 1383                 
 1384                 * inicializo framepointer
 1385  287A 1830                      tsy
 1386                 
 1387                 * prendo el led
 1388  287C                           %LED_INV
 1389                 
 1390                 * inicializo el contador
 1391  2884 8603      inp_rest        ldaa            #INPUTS
 1392  2886 18A700                    staa            CONT,Y
 1393                                 
 1394                 * limpio el display
 1395  2889 CE4260                    ldx             #string
 1396  288C 8604                      ldaa            #4
 1397  288E C620                      ldab            #ESP
 1398  2890 BD29F2                    jsr             clrarray
 1399                 
 1400  2893 BD29E1                    jsr             clr_dis
 1401                 
 1402  2896 86FF                      ldaa            #$FF
 1403  2898 B7425F                    staa            buffer
 1404                 
 1405                 * lectura de teclado
 1406  289B BD2928    wait_kb         jsr             read_kb
 1407  289E 4D                        tsta
 1408  289F 2BFA                      bmi             wait_kb
 1409  28A1 B1425F                    cmpa            buffer
 1410  28A4 27F5                      beq             wait_kb
 1411  28A6 B7425F                    staa            buffer
 1412                                 
 1413  28A9 810F                      cmpa            #B_reset
 1414  28AB 27D7                      beq             inp_rest
 1415  28AD 8103                      cmpa            #B_P1
 1416  28AF 27D3                      beq             inp_rest
 1417  28B1 8107                      cmpa            #B_P2
 1418  28B3 27CF                      beq             inp_rest
 1419                 
 1420  28B5 186A00                    dec             CONT,Y
 1421  28B8 272B                      beq             chk_fire
 1422  28BA 810B                      cmpa            #B_fire
 1423  28BC 27C6                      beq             inp_rest
 1424  28BE 36                        psha
 1425  28BF CE4265                    ldx             #kb_value
 1426  28C2 16                        tab
 1427  28C3 3A                        abx
 1428  28C4 A600                      ldaa            0,X             
 1429  28C6 183C                      pshy
 1430  28C8 18E600                    ldab            CONT,Y
 1431  28CB 183A                      aby
 1432  28CD 18A700                    staa            0,Y
 1433  28D0 1838                      puly
 1434                 
 1435  28D2 33                        pulb
 1436  28D3 BD29D1                    jsr             to_ascii
 1437  28D6 17                        tba
 1438                                 
 1439  28D7 CE4260                    ldx             #string
 1440  28DA BD29C1                    jsr             sh_value
 1441                 
 1442  28DD CE4260                    ldx             #string
 1443  28E0 BD2914                    jsr             show
 1444                 
 1445  28E3 20B6                      bra             wait_kb
 1446                 
 1447  28E5 810B      chk_fire        cmpa            #B_fire
 1448  28E7 269B                      bne             inp_rest
 1449  28E9 18A602                    ldaa            FILA_L,Y
 1450  28EC 810A                      cmpa            #MIN_FIL
 1451  28EE 2594                      blo             inp_rest
 1452  28F0 810F                      cmpa            #MAX_FIL
 1453  28F2 2290                      bhi             inp_rest
 1454  28F4 18A601                    ldaa            COL_L,Y
 1455  28F7 8101                      cmpa            #MIN_COL
 1456  28F9 2589                      blo             inp_rest
 1457  28FB 8106                      cmpa            #MAX_COL
 1458  28FD 2285                      bhi             inp_rest
 1459                 
 1460                 * apago el led
 1461  28FF                           %LED_INV
 1462                 
 1463                 * libero variables locales
 1464  2907 32                        pula
 1465  2908 32                        pula
 1466  2909 32                        pula
 1467                 
 1468  290A 18A602    return          ldaa            FILA_L,Y
 1469  290D 18E601                    ldab            COL_L,Y         
 1470                 
 1471                 * restore de registros
 1472  2910 1838                      puly
 1473  2912 38                        pulx
 1474                 
 1475  2913 39                        rts
 1476                 
 1477                 *------------------------------------
 1478                 * Show: Por IX direccion de string de
 1479                 *       4 caracteres para imprimir
 1480                 *------------------------------------
 1481                 
 1482  2914           show            EQU             *
 1483                 
 1484                 * back up de registros
 1485  2914 3C                        pshx
 1486  2915 37                        pshb
 1487  2916 36                        psha
 1488                 
 1489                 * inicializo contador de posiciones
 1490  2917 C604                      ldab            #LENGTH
 1491                                 
 1492                 * loop para enviar a cada posicion
 1493  2919 5A        sh_loop         decb
 1494  291A 2B08                      bmi             sh_end          ; si no pase por todas las posiciones
 1495  291C A600                      ldaa            0,X             ; tomo del string el caracter
 1496  291E BD29DA                    jsr             outchar         ; y lo imprimo en la posicion actual
 1497  2921 08                        inx
 1498  2922 20F5                      bra             sh_loop
 1499                 
 1500                 * restore de registros                          
 1501  2924 32        sh_end          pula
 1502  2925 33                        pulb
 1503  2926 38                        pulx
 1504  2927 39                        rts
 1505                 
 1506                 *----------------------------------------------
 1507                 * read_kb: AccA: tecla presionada
 1508                 *          o -1
 1509                 *----------------------------------------------
 1510                 
 1511  2928           read_kb         EQU             *
 1512                 
 1513                 * back up de registros
 1514  2928 3C                        pshx
 1515  2929 37                        pshb
 1516                 
 1517                 * creo espacio para variables locales
 1518  292A                           %MALLOC         1               ; variable mascara de filas
 1519  2931                           %MALLOC         1               ; variable mascara de columnas
 1520  2938                           %MALLOC         1               ; variable contador de columnas
 1521  293F                           %MALLOC         1               ; variable contador de tecla
 1522                 
 1523                 * inicializacion de variables
 1524  2946 30                        tsx                             ; framepointer para acceder a locales
 1525  2947 C604                      ldab            #LENGTH         ; contador de fila
 1526  2949 860E                      ldaa            #FIL0           ; mascara para la fila cero
 1527  294B A703                      staa            MASK_FIL,X      
 1528  294D 8610                      ldaa            #COL0           ; mascara para la columna cero
 1529  294F A702                      staa            MASK_COL,X
 1530  2951 4F                        clra                            ; contador de columna
 1531  2952 A701                      staa            COL_CONT,X
 1532  2954 A700                      staa            KB_PRESS,X      ; variable con numero de tecla
 1533                 
 1534                 * loop para barrer y mirar teclado matricial
 1535  2956 86FF      kb_loop         ldaa            #NONE
 1536  2958 5A                        decb                            
 1537  2959 2B2C                      bmi             kb_end          ; me fijo si recorrio todas las filas
 1538  295B A603                      ldaa            MASK_FIL,X      ; enmascaro la siguiente fila
 1539  295D B71003                    staa            ROWS
 1540  2960 0D                        sec                             ; carry para rotacion de byte
 1541  2961 49                        rola                            
 1542  2962 A703                      staa            MASK_FIL,X      ; cambio variable mascara para la proxima fila
 1543                 
 1544  2964 8604                      ldaa            #LENGTH
 1545  2966 A701                      staa            COL_CONT,X
 1546  2968 8610                      ldaa            #COL0           ; inicializo variable para barrer
 1547  296A A702                      staa            MASK_COL,X      ; la columna
 1548                 
 1549  296C 6A01      kb_col          dec             COL_CONT,X      ; me fijo si barrio todas las columnas
 1550  296E 2BE6                      bmi             kb_loop
 1551  2970 B61005                    ldaa            COLS            ; leo el puerto de columnas
 1552  2973 A402                      anda            MASK_COL,X      ; enmascaro columna
 1553  2975 2707                      beq             kb_hit          ; si es nulo apretaron un boton
 1554  2977 48                        lsla                            ; cambio mascara para proxima columna
 1555  2978 A702                      staa            MASK_COL,X
 1556  297A 6C00                      inc             KB_PRESS,X      ; incremento numero de tecla
 1557  297C 20EE                      bra             kb_col
 1558                 
 1559  297E A600      kb_hit          ldaa            KB_PRESS,X      ; apretaron una tecla, lo comparo
 1560  2980 B1425E                    cmpa            kb_buff         ; con la que fue apretada antes
 1561  2983 2602                      bne             kb_end          ; aviso por led
 1562                 
 1563  2985 86FF      kb_none         ldaa            #NONE           ; en caso de que no apreten nada
 1564                 
 1565  2987 B7425E    kb_end          staa            kb_buff         ; actualizo variable
 1566                                         
 1567                 * elimino variables locales
 1568  298A                           %RELMEM         1
 1569  2991                           %RELMEM         1
 1570  2998                           %RELMEM         1
 1571  299F                           %RELMEM         1
 1572                 
 1573                 * restore de registros
 1574  29A6 33                        pulb
 1575  29A7 38                        pulx
 1576                                 
 1577  29A8 39                        rts
 1578                 
 1579                 *----------------------------------------------
 1580                 * init_kb: subrutina para inicializar teclado
 1581                 *----------------------------------------------
 1582                 
 1583  29A9           init_kb         EQU             *
 1584                 
 1585                 * back up de registros
 1586  29A9 36                        psha
 1587                 
 1588                 * inicializacion de teclado             
 1589  29AA 86FF                      ldaa            #NONE
 1590  29AC B7425E                    staa            kb_buff
 1591                 
 1592                 * restore de registros
 1593  29AF 32                        pula
 1594  29B0 39                        rts
 1595                 
 1596                 *--------------------------------
 1597                 * Inicializa display (y teclado)
 1598                 *--------------------------------
 1599                 
 1600  29B1           initdis         EQU             *
 1601                         
 1602  29B1 36                        psha
 1603                 
 1604  29B2 860F                      ldaa            #$0F       ;set for input/output
 1605  29B4 B71007                    staa            DDRC       ;C output
 1606  29B7 B61002                    ldaa            PIOC       ;get current value
 1607  29BA 84FE                      anda            #$FE       ;reset bit 0 to 0
 1608  29BC B71002                    staa            PIOC       ;send it out
 1609                         
 1610  29BF 32                        pula
 1611  29C0 39                        rts
 1612                 
 1613                 *--------------------------------------------------------------
 1614                 * sh_value: toma un string, desplaza los caracteres a izquierda
 1615                 *           y agrega un nuevo caracter
 1616                 *           IX: direccion del string
 1617                 *           AccA: nuevo valor
 1618                 *--------------------------------------------------------------
 1619                 
 1620  29C1           sh_value        EQU             *
 1621                 
 1622                 * back up de registros
 1623  29C1 3C                        pshx
 1624  29C2 37                        pshb
 1625                 
 1626                 * loop para desplazar caracteres
 1627  29C3 E601      v_loop          ldab            1,X             ;tomo elemento siguiente en string
 1628  29C5 2705                      beq             v_end
 1629  29C7 E700                      stab            0,X             ;y lo guardo en posicion actual
 1630  29C9 08                        inx
 1631  29CA 20F7                      bra             v_loop          
 1632                 
 1633  29CC A700      v_end           staa            0,X             ;ingresa nuevo caracter en cadena desplazada
 1634                 
 1635                 * restore de registros
 1636  29CE 33                        pulb
 1637  29CF 38                        pulx
 1638  29D0 39                        rts
 1639                 
 1640                 *----------------------------------------------
 1641                 * toAscii: toma numero de boton del teclado
 1642                 *          y devuelve su correspondiente en
 1643                 *          ascii
 1644                 *          toma  AccB: valor del boton
 1645                 *          devuelve AccB: ascii
 1646                 *----------------------------------------------
 1647                 
 1648  29D1           to_ascii        EQU             *
 1649                 
 1650                 * back up de registros
 1651  29D1 3C                        pshx
 1652                 
 1653                 * inicializacion de variables
 1654  29D2 CE4275                    ldx             #kb_ascii       ; apunto a string con caracteres asignados por tecla
 1655  29D5 3A                        abx                             ; me muevo en string con indice y recupero segun tecla presionada
 1656  29D6 E600                      ldab            0,X             
 1657                 
 1658                 * restore de registros
 1659  29D8 38                        pulx
 1660  29D9 39                        rts
 1661                 
 1662                 *--------------------------------
 1663                 *Outchar: ACCA: Carácter a enviar
 1664                 *           ACCB: Posición (0-3)
 1665                 *--------------------------------
 1666  29DA           outchar         EQU             *
 1667                         
 1668  29DA F71005                    stab            PORTCL          ;set the position 
 1669  29DD B71004                    staa            PORTB           ;set the character
 1670                         
 1671  29E0 39                        rts
 1672                 
 1673                 *-------------------------
 1674                 * clr_dis: Limpia display
 1675                 *-------------------------
 1676                 
 1677  29E1           clr_dis         EQU             *
 1678                 
 1679                 * hago back up de registros
 1680  29E1 37                        pshb
 1681  29E2 36                        psha
 1682                 
 1683                 * inicializo el contador de posiciones
 1684  29E3 C604                      ldab            #LENGTH
 1685                 
 1686                 * loop para limpiar cada posicion
 1687  29E5 5A        clrloop         decb
 1688  29E6 2B07                      bmi             clr_end         ; si no pase por todas las posiciones
 1689  29E8 8620                      ldaa            #ESP            ; cargo en esta posicion espacio blanco
 1690  29EA BD29DA                    jsr             outchar         ; y lo envio
 1691  29ED 20F6                      bra             clrloop         
 1692                 
 1693                 * restore de registros
 1694  29EF 32        clr_end         pula
 1695  29F0 33                        pulb
 1696  29F1 39                        rts
 1697                 
 1698                 *-------------------------------------------------------
 1699                 * clrarray: subrutina para limpiar un array dado
 1700                 * parametros: IX direccion del array
 1701                 *             AccA cantidad de elementos del array
 1702                 *             AccB caracter a poner
 1703                 *-------------------------------------------------------
 1704                 
 1705  29F2           clrarray        EQU             *
 1706                                 
 1707  29F2 4A        cra_loop        deca                            ;contador con cantidad de elementos a limpiar
 1708  29F3 2705                      beq             cra_end
 1709  29F5 E700                      stab            0,X             ;reemplazar elemento por caracter a poner
 1710  29F7 08                        inx
 1711  29F8 20F8                      bra             cra_loop
 1712                                 
 1713  29FA E700      cra_end         stab            0,X
 1714  29FC 39                        rts
 1715                 
 1716                 *=============================================
 1717                 *Subrutina winner: Recibe por stack un 1 si
 1718                 *gano el player 1 y un 0 si gano el player 2.
 1719                 *=============================================
 1720                 
 1721                                 
 1722  29FD           winner          EQU             *
 1723  29FD                           %BACKUP
 1724  2A02 30                        tsx
 1725  2A03 A608                      ldaa            8,x     ;recupero parametro enviado por stack
 1726  2A05 2708                      beq             win2
 1727                 
 1728  2A07           win1            EQU             *
 1729  2A07 CE42BA                    ldx             #string1
 1730  2A0A BD2914                    jsr             show
 1731  2A0D 2006                      bra             end
 1732                 
 1733  2A0F           win2            EQU             *
 1734  2A0F CE42BF                    ldx             #string2
 1735  2A12 BD2914                    jsr             show
 1736                         
 1737  2A15           end             EQU             *
 1738  2A15                           %RESTORE
 1739  2A1A 39                        rts
 1740                 
 1741                 *=============================================
 1742                 *Subrutina turn: Recibe por stack un 1 si
 1743                 *juega el player 1 y un 0 si juega el player 2.
 1744                 *=============================================
 1745                 
 1746  2A1B           turn            EQU             *
 1747  2A1B                           %BACKUP
 1748  2A20 30                        tsx
 1749  2A21 A608                      ldaa            8,x
 1750  2A23 2708                      beq             p2_t
 1751                 
 1752  2A25           p1_t            EQU             *
 1753  2A25 CE42C4                    ldx             #play1
 1754  2A28 BD2914                    jsr             show
 1755  2A2B 20E8                      bra             end
 1756                         
 1757  2A2D           p2_t            EQU             *
 1758  2A2D CE42C9                    ldx             #play2
 1759  2A30 BD2914                    jsr             show
 1760                 
 1761  2A33           end_t           EQU             *
 1762  2A33                           %RESTORE        
 1763  2A38 39                        rts
 1764                 
 1765                 *************
 1766                 * VARIABLES *
 1767                 *************
 1768                 ***STACK***
 1769  4000                           ORG             $4000
 1770  4000           stack           RMB             600
 1771  4257           STACKP          EQU             *-1
 1772                 
 1773                 ***MAIN VARIABLES***
 1774  4258           player          RMB             1               ;variable de jugador
 1775  4259           letra_p         RMB             1
 1776  425A           num_p           RMB             1
 1777  425B           cant_sub        RMB             1
 1778  425C           cant_shi        RMB             1
 1779  425D           tot_pos         RMB             1
 1780                 
 1781                 ***KEYBOARD VARIABLES***
 1782  425E           kb_buff         RMB             1
 1783  425F           buffer          RMB             1
 1784                 
 1785  4260 20202020  string          FCC             '    '
 1786  4264 00                        FCB             0
 1787                 
 1788  4265 0A0B0CFF  kb_value        FCB             10,11,12,255,13,14,15,255,1,2,3,255,4,5,6,255
       4269 0D0E0FFF
       426D 010203FF
       4271 040506FF
 1789                 
 1790  4275 41424320  kb_ascii        FCC             'ABC DEF 123 456'
       4279 44454620
       427D 31323320
       4281 343536
 1791                 
 1792                 ***ARREGLO DE BARCOS TOCADOS***
 1793  0005           SUB             EQU             5
 1794  0004           SHI             EQU             4
 1795  0002           EL_SIZE         EQU             2
 1796  000D           MAX_ATT         EQU             SUB*1+SHI*2
 1797  001B           HITSIZE         EQU             EL_SIZE*MAX_ATT+1
 1798  4284           hitlist         RMB             HITSIZE*2
 1799                 
 1800                 ***DISPLAY MESSAGES VARIABLES***
 1801  42BA 57494E31  string1         FCC     'WIN1'
 1802  42BE 00                        FCB     00
 1803  42BF 57494E32  string2         FCC     'WIN2'
 1804  42C3 00                        FCB     00
 1805                 
 1806  42C4 2D50322D  play1           FCC     '-P2-'
 1807  42C8 00                        FCB     0
 1808  42C9 2D50312D  play2           FCC     '-P1-'
 1809  42CD 00                        FCB     0
 1810                 
 1811  42CE 5355424D  subm            FCC     'SUBM'
 1812  42D2 00                        FCB     0
 1813  42D3 43415247  carg            FCC     'CARG'
 1814  42D7 00                        FCB     0
 1815  42D8 504C4159  play            FCC     'PLAY'
 1816  42DC 00                        FCB     0
 1817                 
 1818  42DD           arry_pr         RMB             N_PR*SA_SIZE
 1819  43A5           arry_aux        RMB             N_AUX*SA_SIZE
 1820                 
 1821  43AD 53554231  msg_sub         FCC             'SUB1'
 1822  43B1 00                        FCB             0
 1823  43B2 53554232                  FCC             'SUB2'
 1824  43B6 00                        FCB             0
 1825  43B7 53554233                  FCC             'SUB3'
 1826  43BB 00                        FCB             0
 1827  43BC 53554234                  FCC             'SUB4'
 1828  43C0 00                        FCB             0
 1829  43C1 53554235                  FCC             'SUB5'
 1830  43C5 00                        FCB             0
 1831                 
 1832  43C6 43415231  msg_shi         FCC             'CAR1'
 1833  43CA 00                        FCB             0       
 1834  43CB 43415232                  FCC             'CAR2'
 1835  43CF 00                        FCB             0       
 1836  43D0 43415233                  FCC             'CAR3'
 1837  43D4 00                        FCB             0
 1838  43D5 43415234                  FCC             'CAR4'
 1839  43D9 00                        FCB             0
 1840                 
 1841                 ***MATRICES DE TABLERO DE CADA JUGADOR***
 1842  5000                           ORG             $5000
 1843  5000 03030303  p_board         FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5004 0303
 1844  5006 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       500A 0303
 1845  500C 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5010 0303
 1846  5012 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5016 0303
 1847  5018 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       501C 0303
 1848  501E 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5022 0303
 1849                 
 1850  5024 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5028 0303
 1851  502A 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       502E 0303
 1852  5030 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5034 0303
 1853  5036 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       503A 0303
 1854  503C 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5040 0303
 1855  5042 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5046 0303
 1856                 
 1857                 ***MATRIZ DE DISPLAY***
 1858  5F00                           ORG             $5F00
 1859  5F00 03030303  display         FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5F04 0303
 1860  5F06 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5F0A 0303
 1861  5F0C 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5F10 0303
 1862  5F12 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5F16 0303
 1863  5F18 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5F1C 0303
 1864  5F1E 03030303                  FCB             WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP,WAT_NP
       5F22 0303
 1865                 
 1866                                 
 1867  5F24                           END

    Errors:  None         ###########
    Bytes:   2841         # main_bn #
    CRC:     181C         ###########

